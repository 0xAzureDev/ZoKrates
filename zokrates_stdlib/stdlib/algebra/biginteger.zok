import "utils/pack/bool/unpack_unchecked" as unpack;
import "utils/pack/bool/pack" as pack;
import "utils/casts/u32_to_field" as u32_to_field;

const u32 LIMB_BITWIDTH = 32;

struct BigInteger<N> {
    field[N] limbs;
}

// Construct a big integer from `N` limbs
def bigint_from_limbs<N, M>(field[N] limbs) -> BigInteger<M> {
    assert(M >= N, "invalid number of limbs");
    return BigInteger { limbs: [...limbs, ...[0; M-N]] };
}

// Construct a big integer from `N` u32 limbs
def bigint_from_u32_limbs<N, M>(u32[N] limbs) -> BigInteger<M> {
    assert(M >= N, "invalid number of limbs");
    field[N] mut f = [0; N];
    for u32 i in 0..N {
        f[i] = u32_to_field(limbs[i]);
    }
    return bigint_from_limbs(f);
}

// Expand big integer from `N` limbs to `M` limbs
def bigint_expand<N, M>(BigInteger<N> input) -> BigInteger<M> {
    return bigint_from_limbs(input.limbs);
}

// Big integer addition
def bigint_add<N, M>(BigInteger<N> a, BigInteger<N> b) -> BigInteger<M> {
    assert(M == N + 1);
    BigInteger<M> mut c = bigint_from_limbs([0; N]);
    field mut carry = 0;
    for u32 i in 0..N {
        field sum = a.limbs[i] + b.limbs[i] + carry;
        bool[LIMB_BITWIDTH + 1] bits = unpack(sum);
        carry = bits[0] ? 1 : 0;
        c.limbs[i] = sum - carry * (1 << LIMB_BITWIDTH);
    }
    c.limbs[N] = carry;
    return c;
}

// Big integer subtraction
// Note: assumes a >= b
def bigint_sub<N>(BigInteger<N> a, BigInteger<N> b) -> BigInteger<N> {
    BigInteger<N> mut c = bigint_from_limbs([0; N]);
    field mut borrow = 0;
    for u32 i in 0..N {
        c.limbs[i] = borrow * (1 << LIMB_BITWIDTH) + (a.limbs[i] - b.limbs[i]);
        bool[LIMB_BITWIDTH + 1] bits = unpack(a.limbs[i] + (1 << LIMB_BITWIDTH) - b.limbs[i]);
        borrow = 1 - (bits[0] ? 1 : 0);
    }
    return c;
}

// Right shift by `n` limbs
def bigint_rshift_limb<N>(BigInteger<N> mut a, u32 n) -> BigInteger<N> {
    assert(n < N);
    for u32 i in 0..N-n {
        a.limbs[i] = a.limbs[i + n];
    }
    for u32 i in N-n..N {
        a.limbs[i] = 0;
    }
    return a;
}

// Left shift by `n` limbs
def bigint_lshift_limb<N>(BigInteger<N> mut a, u32 n) -> BigInteger<N> {
    assert(n < N);
    for u32 i in 0..N-n {
        u32 j = N - i - 1;
        a.limbs[j] = a.limbs[j - n];
    }
    for u32 i in 0..n {
        a.limbs[i] = 0;
    }
    return a;
}

// Check equality of two big integers
def bigint_eq<N>(BigInteger<N> a, BigInteger<N> b) -> bool {
    bool mut eq = true;
    for u32 i in 0..N {
        eq = eq && (a.limbs[i] == b.limbs[i]);
    }
    return eq;
}

// Check if a big integer is equal to 0
def bigint_is_zero<N>(BigInteger<N> a) -> bool {
    BigInteger<N> zero = bigint_from_limbs([0; N]);
    return bigint_eq(a, zero);
}