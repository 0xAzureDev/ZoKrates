from "field" import FIELD_SIZE_IN_BITS;
import "utils/pack/bool/unpack_unchecked" as unpack;

struct bigint<N> {
    field[N] limbs;
}

def bigint_from_limbs<N, P>(field[N] values) -> bigint<P> {
    assert(P >= N, "invalid number of limbs");
    return bigint { limbs: [...values, ...[0; P-N]] };
}

// Big integer addition
def bigint_add<N, M>(bigint<N> a, bigint<N> b) -> bigint<N> {
    assert(M < FIELD_SIZE_IN_BITS - 1);
    bigint<N> mut c = bigint_from_limbs([0; N]);
    field mut carry = 0;
    for u32 i in 0..N {
        field sum = a.limbs[i] + b.limbs[i] + carry;
        bool[M + 1] bits = unpack(sum);
        carry = bits[0] ? 1 : 0;
        c.limbs[i] = sum - carry * (1 << M);
    }
    return c;
}

// Big integer subtraction (assumes a >= b)
def bigint_sub<N, M>(bigint<N> a, bigint<N> b) -> bigint<N> {
    assert(M < FIELD_SIZE_IN_BITS - 1);
    bigint<N> mut c = bigint_from_limbs([0; N]);
    field mut borrow = 0;
    for u32 i in 0..N {
        c.limbs[i] = borrow * (1 << M) + (a.limbs[i] - b.limbs[i]);
        bool[M + 1] bits = unpack(a.limbs[i] + (1 << M) - b.limbs[i]);
        borrow = bits[0] ? 0 : 1;
    }
    return c;
}

// Right shift by `n` limbs
def bigint_rshift_limb<N>(bigint<N> mut a, u32 n) -> bigint<N> {
    assert(n < N);
    for u32 i in 0..N-n {
        a.limbs[i] = a.limbs[i + n];
    }
    for u32 i in N-n..N {
        a.limbs[i] = 0;
    }
    return a;
}

// Left shift by `n` limbs
def bigint_lshift_limb<N>(bigint<N> mut a, u32 n) -> bigint<N> {
    assert(n < N);
    for u32 i in 0..N-n {
        u32 j = N - i - 1;
        a.limbs[j] = a.limbs[j - n];
    }
    for u32 i in 0..n {
        a.limbs[i] = 0;
    }
    return a;
}

// Checks equality of two big integers
def bigint_eq<N>(bigint<N> a, bigint<N> b) -> bool {
    bool mut eq = true;
    for u32 i in 0..N {
        eq = eq && (a.limbs[i] == b.limbs[i]);
    }
    return eq;
}

// Checks if a big integer is equal to 0
def bigint_is_zero<N>(bigint<N> a) -> bool {
    bigint<N> zero = bigint_from_limbs([0; N]);
    return bigint_eq(a, zero);
}