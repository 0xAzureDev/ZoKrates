import "./decodeOrder.code"
import "./limitLessThanPrice.code"

def tupleForTokensWithValue(field value) -> (field[3]):
  return [value, value, value]

def tupleForTokenPairsWithValue(field value) -> (field[9]):
  return [value, value, value, value, value, value, value, value, value]

def findPairInTokenPairList(field[9] pairs, field sourceToken, field targetToken) -> (field):
  return pairs[sourceToken * 3 + targetToken]

// add `volume` to element `token` in `volumeToken`
def addVolumesForOrder(field[3] volumeToken, field token, field volume) -> (field[3]):
  for field i in 0..3 do
    volumeToken[i] = volumeToken[i] + if token == i then volume else 0 fi
  endfor
  return volumeToken

def updateHighestTouchedOrder(field[9] highestTouchedOrder, field sourceToken, field targetToken, field limit, field volume) -> (field[9]):

  field highest = findPairInTokenPairList(highestTouchedOrder, sourceToken, targetToken)

  field shouldUpdate = if 0 < volume then 1 else 0 fi
  shouldUpdate = if highest < limit then shouldUpdate else 0 fi

  highestTouchedOrder[sourceToken * 3 + targetToken] = if shouldUpdate == 1 then limit else highestTouchedOrder[sourceToken * 3 + targetToken] fi

  return highestTouchedOrder

def verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(field[9] highestTouchedOrder, field sourceAmount, field sourceToken, field targetToken, field limit, field volume) -> (field):

  field highest = findPairInTokenPairList(highestTouchedOrder, sourceToken, targetToken)

  field valid = if limit < highest then 1 - (sourceAmount - volume) else 1 fi
  return valid

def checkConstraints(field amount1, field sourceToken1, field targetToken1, field limit1, field amount2, field sourceToken2, field targetToken2, field limit2, field amount3, field sourceToken3, field targetToken3, field limit3, field[3] volume, field[3] priceToken) -> (field):
  // volumes are not larger than in original offer
  field validVolumesLowerAmount1 = if amount1 < volume[0] then 0 else 1 fi
  validVolumesLowerAmount1 == 1
  field validVolumesLowerAmount2 = if amount2 < volume[1] then 0 else 1 fi
  validVolumesLowerAmount2 == 1
  field validVolumesLowerAmount3 = if amount3 < volume[2] then 0 else 1 fi
  validVolumesLowerAmount3 == 1

  field sourceTokenPriceOrder1 = priceToken[sourceToken1]
  field targetTokenPriceOrder1 = priceToken[targetToken1]
  field sourceTokenPriceOrder2 = priceToken[sourceToken2]
  field targetTokenPriceOrder2 = priceToken[targetToken2]
  field sourceTokenPriceOrder3 = priceToken[sourceToken3]
  field targetTokenPriceOrder3 = priceToken[targetToken3]

  // orders are only touched, if the limit price is below the calculated price:
  field validLimitLessThanPrice1 = if volume[0] == 0 then 1 else limitLessThanPrice(sourceTokenPriceOrder1, targetTokenPriceOrder1, limit1) fi
  validLimitLessThanPrice1 == 1
  field validLimitLessThanPrice2 = if volume[1] == 0 then 1 else limitLessThanPrice(sourceTokenPriceOrder2, targetTokenPriceOrder2, limit2) fi
  validLimitLessThanPrice2 == 1
  field validLimitLessThanPrice3 = if volume[2] == 0 then 1 else limitLessThanPrice(sourceTokenPriceOrder3, targetTokenPriceOrder3, limit3) fi
  validLimitLessThanPrice3 == 1

  // the amount of sell volume for a token equals its buy volume:
  buyVolumeToken = tupleForTokensWithValue(0)
  sellVolumeToken = tupleForTokensWithValue(0)

  buyVolumeToken = addVolumesForOrder(buyVolumeToken, targetToken1, volume[0] * sourceTokenPriceOrder1)
  sellVolumeToken = addVolumesForOrder(sellVolumeToken, sourceToken1, volume[0] * sourceTokenPriceOrder1)

  buyVolumeToken = addVolumesForOrder(buyVolumeToken, targetToken2, volume[1] * sourceTokenPriceOrder2)
  sellVolumeToken = addVolumesForOrder(sellVolumeToken, sourceToken2, volume[1] * sourceTokenPriceOrder2)

  buyVolumeToken = addVolumesForOrder(buyVolumeToken, targetToken3, volume[2] * sourceTokenPriceOrder3)
  sellVolumeToken = addVolumesForOrder(sellVolumeToken, sourceToken3, volume[2] * sourceTokenPriceOrder3)

  buyVolumeToken == sellVolumeToken

  // If an order σ ∈ Oi→j with a limit price p has a positive trading volume, then every order in Oi→j with a lower limit price should be completely fulfilled.
  highestTouchedOrder = tupleForTokenPairsWithValue(0)

  highestTouchedOrder = updateHighestTouchedOrder(highestTouchedOrder, sourceToken1, targetToken1, limit1, volume[0])

  highestTouchedOrder = updateHighestTouchedOrder(highestTouchedOrder, sourceToken2, targetToken2, limit2, volume[1])

  highestTouchedOrder = updateHighestTouchedOrder(highestTouchedOrder, sourceToken3, targetToken3, limit3, volume[2])

  valid = verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(highestTouchedOrder, amount1, sourceToken1, targetToken1, limit1, volume[0])
  valid == 1
  valid = verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(highestTouchedOrder, amount2, sourceToken2, targetToken2, limit2, volume[1])
  valid == 1
  valid = verifyCompletelyFulfilledIfLimitLowerHighestTouchedOrder(highestTouchedOrder, amount3, sourceToken3, targetToken3, limit3, volume[2])
  valid == 1

  return 1 // Could return total volume to maximize for

def main(private field[3] encodedOrder, private field[3] bitmapOrder, private field[3] volume, private field[3] priceToken) -> (field):
  // Remove orders that are not double signed
  encodedOrder = [if bitmapOrder[0] == 1 then encodedOrder[0] else 0 fi, if bitmapOrder[1] == 1 then encodedOrder[1] else 0 fi, if bitmapOrder[2] == 1 then encodedOrder[2] else 0 fi]

  // Decode orders
  amount1, sourceToken1, targetToken1, limit1 = decodeOrder(encodedOrder[0])
  amount2, sourceToken2, targetToken2, limit2 = decodeOrder(encodedOrder[1])
  amount3, sourceToken3, targetToken3, limit3 = decodeOrder(encodedOrder[2])

  return checkConstraints(amount1, sourceToken1, targetToken1, limit1, amount2, sourceToken2, targetToken2, limit2, amount3, sourceToken3, targetToken3, limit3, volume, priceToken)